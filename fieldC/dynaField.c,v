head	1.38;
access;
symbols;
locks
	ndd:1.38; strict;
comment	@ * @;


1.38
date	2018.08.10.16.26.12;	author ndd;	state Exp;
branches;
next	1.37;

1.37
date	2018.08.08.13.48.00;	author ndd;	state Exp;
branches;
next	1.36;

1.36
date	2018.07.26.20.08.09;	author ndd;	state Exp;
branches;
next	1.35;

1.35
date	2018.07.25.19.59.42;	author ndd;	state Exp;
branches;
next	1.34;

1.34
date	2018.07.25.17.00.24;	author ndd;	state Exp;
branches;
next	1.33;

1.33
date	2018.07.24.17.52.08;	author ndd;	state Exp;
branches;
next	1.32;

1.32
date	2018.07.24.17.42.10;	author ndd;	state Exp;
branches;
next	1.31;

1.31
date	2018.07.20.18.41.19;	author ndd;	state Exp;
branches;
next	1.30;

1.30
date	2018.07.19.14.30.16;	author ndd;	state Exp;
branches;
next	1.29;

1.29
date	2018.07.18.18.00.03;	author ndd;	state Exp;
branches;
next	1.28;

1.28
date	2018.07.18.16.17.20;	author ndd;	state Exp;
branches;
next	1.27;

1.27
date	2018.06.12.18.35.25;	author ndd;	state Exp;
branches;
next	1.26;

1.26
date	2018.06.06.17.37.16;	author ndd;	state Exp;
branches;
next	1.25;

1.25
date	2018.06.06.16.08.13;	author ndd;	state Exp;
branches;
next	1.24;

1.24
date	2018.05.02.19.03.08;	author ndd;	state Exp;
branches;
next	1.23;

1.23
date	2018.05.01.17.35.18;	author ndd;	state Exp;
branches;
next	1.22;

1.22
date	2018.04.30.20.53.58;	author ndd;	state Exp;
branches;
next	1.21;

1.21
date	2018.04.30.20.32.17;	author ndd;	state Exp;
branches;
next	1.20;

1.20
date	2018.04.30.19.02.51;	author ndd;	state Exp;
branches;
next	1.19;

1.19
date	2018.04.27.21.27.13;	author ndd;	state Exp;
branches;
next	1.18;

1.18
date	2018.04.23.14.44.27;	author ndd;	state Exp;
branches;
next	1.17;

1.17
date	2018.04.18.19.22.50;	author ndd;	state Exp;
branches;
next	1.16;

1.16
date	2018.04.17.19.44.11;	author ndd;	state Exp;
branches;
next	1.15;

1.15
date	2018.04.17.15.30.52;	author ndd;	state Exp;
branches;
next	1.14;

1.14
date	2018.04.17.14.08.06;	author ndd;	state Exp;
branches;
next	1.13;

1.13
date	2018.04.13.16.21.26;	author ndd;	state Exp;
branches;
next	1.12;

1.12
date	2018.04.11.17.52.11;	author ndd;	state Exp;
branches;
next	1.11;

1.11
date	2018.04.07.21.42.58;	author ndd;	state Exp;
branches;
next	1.10;

1.10
date	2018.04.05.17.48.00;	author ndd;	state Exp;
branches;
next	1.9;

1.9
date	2018.04.05.13.10.10;	author ndd;	state Exp;
branches;
next	1.8;

1.8
date	2018.04.04.17.18.53;	author ndd;	state Exp;
branches;
next	1.7;

1.7
date	2018.04.03.17.15.19;	author ndd;	state Exp;
branches;
next	1.6;

1.6
date	2018.03.30.16.59.36;	author ndd;	state Exp;
branches;
next	1.5;

1.5
date	2018.03.26.14.33.32;	author ndd;	state Exp;
branches;
next	1.4;

1.4
date	2018.03.21.18.05.42;	author ndd;	state Exp;
branches;
next	1.3;

1.3
date	2018.03.19.17.57.49;	author ndd;	state Exp;
branches;
next	1.2;

1.2
date	2018.03.16.15.36.04;	author ndd;	state Exp;
branches;
next	1.1;

1.1
date	2018.03.16.15.16.08;	author ndd;	state Exp;
branches;
next	;


desc
@C version of dynaField.m
@


1.38
log
@have to pass sampling frequency to readExpData
@
text
@/*
% function [intensity, FIELD_PARAMS]=dynaField(FIELD_PARAMS, threads, numNodes,
%	lownslow)
*
%
% Generate intensity values at the nodal locations for conversion to force and
% input into the dyna deck.
%
% INPUTS:
%   FIELD_PARAMS.alpha (float) - absorption (dB/cm/MHz)
%   FIELD_PARAMS.measurementPointsandNodes - nodal IDs and spatial locations
%                                            from field2dyna.m
%   FIELD_PARAMS.Fnum (float) - F/#
%   FIELD_PARAMS.focus - [x y z] (m)
%   FIELD_PARAMS.Frequency (float) - push frequency (MHz)
%                                    6.67 (VF10-5)
%                                    4.21 (VF7-3)
%   FIELD_PARAMS.Transducer (string) - 'vf105'; select the
%       transducer-dependent parameters to use for the simulation
%   FIELD_PARAMS.Impulse (string) - 'gaussian','exp'; use a Gaussian function
%       based on the defined fractional bandwidth and center
%       frequency, or use the experimentally-measured impulse
%       response
%   threads (int) - number of parallel threads to use [default = numCores]
%   lownslow (bool) - low RAM footprint, but much slower
%   numNodes - number of nodes from readMpn
%
% OUTPUT:
%   intensity - intensity values at all of the node locations
%   FIELD_PARAMS - field parameter structure
%
% EXAMPLE:
%   [intensity, FIELD_PARAMS] = dynaField(FIELD_PARAMS)
%
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "field.h"		/* includes field_II.h */
#include "cJSON.h"

#define RECT 1	/* type of info we want from xdc_get */
#define ROWS_RECT 26	/* rows xdc_get returns for each rectangle */
#define ROWS_TRI 15	/* rows xdc_get returns for each triangle */

sys_con_type   *sys_con;      /*  System constants for Field II */ 

dynaField(struct FieldParams params, int threads, int numNodes, int lowNslow,
	int verbose)
{
int dynaWrite();
int i, j;
aperture_type *Th = NULL;
int32 info;
cJSON *commands, *probeInfo;
cJSON *jsonTemp;
FILE *jsonInput;
char jsonFileName[128];
long len;
char *data, *out;
int noElements, noSubX, noSubY;
int noElementsY;
double width, height, kerf, Rconvex, Rfocus, eleSize, radius;
double fractBandwidth, centerFreq;
point_type *points;
double exciteFreqHz;
signal_type *excitationPulse = NULL;
signal_type *impulseResponse = NULL, *gaussPulse();
signal_type **pressure = NULL;
double *intensity;
double stepSize;
double freqAtt, attF0, att;
int numCYC = 50;
int numSteps;
double lensCorrection, correctAxialLens();
double temp;
char outFileName[80];
int xdcGetSize;

/* how do I do check_add_probes? */

/*
 * initialize Field II; field_init is in the provided c library; the '-1'
 * arg supresses ascii output.
 */
	
	sys_con = field_init(-1);

/* set transducer-independent parameters */

	fprintf(stderr, "in dynaField verbose %d\n", verbose);

	if (verbose >= 1) {
		fprintf(stderr, "sampling frequency %d\n", params.samplingFrequencyHz);
		fprintf(stderr, "alpha_dBcmMHz %f\n", params.alpha_dBcmMHz);
		fprintf(stderr, "fnum %f\n", params.fnum);
		fprintf(stderr, "frequency %f\n", params.frequencyMHz);
		fprintf(stderr, "transducer %s transducer Type %s\n",
			params.transducer, params.transducerType);
		fprintf(stderr, "points %f %f %f\n",
			params.pointsAndNodes[0].x,
			params.pointsAndNodes[0].y,
			params.pointsAndNodes[0].z);
		}

/*
 * splint throws a warning here because set_field wants doubles even though
 * some params are really ints. I'm going to ignore it; I think the code is
 * clearer without the cast.
 */

	set_field("c", params.soundSpeed_MperSec);
	set_field("fs", params.samplingFrequencyHz);

	set_field("threads", params.threads);

	if (verbose >= 1) fprintf(stderr, "PARALLEL THREADS: %d param threads %d\n",
		threads, params.threads);

/*
 * okay. I think this is what is going on. we have to compute 'Th', which
 * comes from one of the xdc calls in fieldII, and we have to compute
 * 'impulseResponse'. impulseResponse is either computed as a gaussian, or
 * computed from experimental data read in from a probe file. at this point
 * it's not clear what other info I'll need from the probe file.
 */

/* get info from JSON; this assumes that the JSON probe file is local */
/* 	strcpy(jsonFileName, "./c52.json"); */
	sprintf(jsonFileName, "./%s.json", params.transducer);

	if ((jsonInput = fopen(jsonFileName, "rb")) == NULL) {
		fprintf(stderr, "couldn't open json file %s\n", jsonFileName);
		return(0);
		}

	fseek(jsonInput, 0, SEEK_END);
	len = ftell(jsonInput);

	fseek(jsonInput, 0, SEEK_SET);

	if ((data = (char *)malloc(len+1)) == NULL) {
		fprintf(stderr, "couldn't allocate space for json data\n");
		return(0);
		}

	if (fread(data, 1, len, jsonInput) != len) {
		fprintf(stderr, "couldn't read json data\n");
		return(0);
		}

	fclose(jsonInput);

	probeInfo = cJSON_Parse(data);
	if (!probeInfo) {
		printf("Error before: [%s]\n", cJSON_GetErrorPtr());
		return(0);
		}

	else {
		out = cJSON_Print(probeInfo);
		free(out);
		}

	if (verbose >= 2) fprintf(stderr, "array size %d\n", cJSON_GetArraySize(probeInfo));

/* if any of the requested items is missing, it's a fatal error.
 * note that the elements that are in a probe file depend on the probe, so
 * we have to use 'transducerType' to decide what to parse.
 */

/* set aperture. we currently recognize 4 types:
 *
 *	concave
 *	convex_focused_array
 *	focused_multirow
 *	focused_array
 *
 */

	if (strstr(params.transducerType, "concave") != NULL) {
/* optical piston only? should this be handled differently? */

		if (verbose >= 1) fprintf(stderr, "calling xdc_concave\n");

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "fractionalBandwidth")) == NULL) {
			fprintf(stderr, "couldn't find fractBandwidth in probe file\n");
			return(0);
			}
		fractBandwidth = jsonTemp->valuedouble;

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "eleSize")) == NULL) {
			fprintf(stderr, "couldn't find eleSize in probe file\n");
			return(0);
			}
		eleSize = jsonTemp->valuedouble;

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "radius")) == NULL) {
			fprintf(stderr, "couldn't find radius in probe file\n");
			return(0);
			}
		radius = jsonTemp->valuedouble;

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "Rfocus")) == NULL) {
			fprintf(stderr, "couldn't find Rfocus in probe file\n");
			return(0);
			}
		Rfocus = jsonTemp->valuedouble;

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "centerFrequency")) == NULL) {
			fprintf(stderr, "couldn't find centerFreq in probe file\n");
			return(0);
			}
		centerFreq = jsonTemp->valuedouble;

		Th = xdc_concave(radius, Rfocus, eleSize);
		if (Th == NULL) {
			fprintf(stderr, "error calling xdc_concave\n");
			return(0);
			}
		}

	else if (strstr(params.transducerType, "convex_focused_array") != NULL) {

		if (verbose >= 1) fprintf(stderr, "calling xdc_convex_focused_array\n");

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "noElements")) == NULL) {
			fprintf(stderr, "couldn't find noElements in probe file\n");
			return(0);
			}
		noElements = jsonTemp->valueint;

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "noSubX")) == NULL) {
			fprintf(stderr, "couldn't find noSubX in probe file\n");
			return(0);
			}
		noSubX = jsonTemp->valueint;

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "noSubY")) == NULL) {
			fprintf(stderr, "couldn't find noSubY in probe file\n");
			return(0);
			}
		noSubY = jsonTemp->valueint;

		if (verbose >= 2) fprintf(stderr, "elements %d subX %d subY %d\n", noElements,
			noSubX, noSubY);

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "width")) == NULL) {
			fprintf(stderr, "couldn't find width in probe file\n");
			return(0);
			}
		width = jsonTemp->valuedouble;

		if (verbose >= 2) fprintf(stderr, "width %f\n", width);

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "height")) == NULL) {
			fprintf(stderr, "couldn't find height in probe file\n");
			return(0);
			}
		height = jsonTemp->valuedouble;

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "kerf")) == NULL) {
			fprintf(stderr, "couldn't find kerf in probe file\n");
			return(0);
			}
		kerf = jsonTemp->valuedouble;

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "Rconvex")) == NULL) {
			fprintf(stderr, "couldn't find Rconvex in probe file\n");
			return(0);
			}
		Rconvex = jsonTemp->valuedouble;

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "Rfocus")) == NULL) {
			fprintf(stderr, "couldn't find Rfocus in probe file\n");
			return(0);
			}
		Rfocus = jsonTemp->valuedouble;

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "fractionalBandwidth")) == NULL) {
			fprintf(stderr, "couldn't find fractBandwidth in probe file\n");
			return(0);
			}
		fractBandwidth = jsonTemp->valuedouble;

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "centerFrequency")) == NULL) {
			fprintf(stderr, "couldn't find centerFreq in probe file\n");
			return(0);
			}
		centerFreq = jsonTemp->valuedouble;

		if (verbose >= 2) fprintf(stderr, "type %s\n", cJSON_GetObjectItem(probeInfo, "probeType")->valuestring);


		if (verbose >= 2) fprintf(stderr, "%d %f %f %f %f %f %d %d %f %f %f\n",
			noElements, width, height, kerf, Rconvex, Rfocus, noSubX,
			noSubY, params.focusM.x, params.focusM.y, params.focusM.z);

		Th = xdc_convex_focused_array(noElements, width, height, kerf, Rconvex,
			Rfocus, noSubX, noSubY, params.focusM);
		if (Th == NULL) {
			fprintf(stderr, "error calling xdc_convex_focused_array\n");
			return(0);
			}
		if (verbose >= 2) fprintf(stderr, "xdc_convex_focused_array; info: %s %s\n",
			Th->information.name, Th->information.create_date);
		}

	else if (strstr(params.transducerType, "focused_multirow") != NULL) {
/* linear only? should this be handled differently? */

		if (verbose >= 1) fprintf(stderr, "calling xdc_focused_multirow\n");

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "noElements")) == NULL) {
			fprintf(stderr, "couldn't find noElements in probe file\n");
			return(0);
			}
		noElements = jsonTemp->valueint;

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "noSubX")) == NULL) {
			fprintf(stderr, "couldn't find noSubX in probe file\n");
			return(0);
			}
		noSubX = jsonTemp->valueint;

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "noSubY")) == NULL) {
			fprintf(stderr, "couldn't find noSubY in probe file\n");
			return(0);
			}
		noSubY = jsonTemp->valueint;

		if (verbose >= 2) fprintf(stderr, "elements %d subX %d subY %d\n", noElements,
			noSubX, noSubY);

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "width")) == NULL) {
			fprintf(stderr, "couldn't find width in probe file\n");
			return(0);
			}
		width = jsonTemp->valuedouble;

		if (verbose >= 2) fprintf(stderr, "width %f\n", width);

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "height")) == NULL) {
			fprintf(stderr, "couldn't find height in probe file\n");
			return(0);
			}
		height = jsonTemp->valuedouble;

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "kerf")) == NULL) {
			fprintf(stderr, "couldn't find kerf in probe file\n");
			return(0);
			}
		kerf = jsonTemp->valuedouble;

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "Rfocus")) == NULL) {
			fprintf(stderr, "couldn't find Rfocus in probe file\n");
			return(0);
			}
		Rfocus = jsonTemp->valuedouble;

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "fractionalBandwidth")) == NULL) {
			fprintf(stderr, "couldn't find fractBandwidth in probe file\n");
			return(0);
			}
		fractBandwidth = jsonTemp->valuedouble;

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "centerFrequency")) == NULL) {
			fprintf(stderr, "couldn't find centerFreq in probe file\n");
			return(0);
			}
		centerFreq = jsonTemp->valuedouble;

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "noElementsY")) == NULL) {
			fprintf(stderr, "couldn't find noElementsY in probe file\n");
			return(0);
			}
		noElementsY = jsonTemp->valuedouble;

		Th = xdc_focused_multirow(noElements, width, noElementsY, &height,
			kerf, kerf, Rfocus, noSubX, noSubY, params.focusM);
		if (Th == NULL) {
			fprintf(stderr, "error calling xdc_focused_multirow\n");
			return(0);
			}
		}

	else if (strstr(params.transducerType, "focused_array") != NULL) {

		if (verbose >= 1) fprintf(stderr, "calling xdc_focused_array\n");

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "noElements")) == NULL) {
			fprintf(stderr, "couldn't find noElements in probe file\n");
			return(0);
			}
		noElements = jsonTemp->valueint;

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "noSubX")) == NULL) {
			fprintf(stderr, "couldn't find noSubX in probe file\n");
			return(0);
			}
		noSubX = jsonTemp->valueint;

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "noSubY")) == NULL) {
			fprintf(stderr, "couldn't find noSubY in probe file\n");
			return(0);
			}
		noSubY = jsonTemp->valueint;

		if (verbose >= 2) fprintf(stderr, "elements %d subX %d subY %d\n", noElements,
			noSubX, noSubY);

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "width")) == NULL) {
			fprintf(stderr, "couldn't find width in probe file\n");
			return(0);
			}
		width = jsonTemp->valuedouble;

		if (verbose >= 2) fprintf(stderr, "width %f\n", width);

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "height")) == NULL) {
			fprintf(stderr, "couldn't find height in probe file\n");
			return(0);
			}
		height = jsonTemp->valuedouble;

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "kerf")) == NULL) {
			fprintf(stderr, "couldn't find kerf in probe file\n");
			return(0);
			}
		kerf = jsonTemp->valuedouble;

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "Rfocus")) == NULL) {
			fprintf(stderr, "couldn't find Rfocus in probe file\n");
			return(0);
			}
		Rfocus = jsonTemp->valuedouble;

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "fractionalBandwidth")) == NULL) {
			fprintf(stderr, "couldn't find fractBandwidth in probe file\n");
			return(0);
			}
		fractBandwidth = jsonTemp->valuedouble;

		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "centerFrequency")) == NULL) {
			fprintf(stderr, "couldn't find centerFreq in probe file\n");
			return(0);
			}
		centerFreq = jsonTemp->valuedouble;

		if (verbose >= 2) fprintf(stderr, "type %s\n", cJSON_GetObjectItem(probeInfo, "probeType")->valuestring);


		if (verbose >= 2) fprintf(stderr, "%d %f %f %f %f %f %d %d %f %f %f\n",
			noElements, width, height, kerf, Rconvex, Rfocus, noSubX,
			noSubY, params.focusM.x, params.focusM.y, params.focusM.z);

		Th = xdc_focused_array(noElements, width, height, kerf,
			Rfocus, noSubX, noSubY, params.focusM);
		if (Th == NULL) {
			fprintf(stderr, "error calling xdc_focused_array\n");
			return(0);
			}
		if (verbose >= 2) fprintf(stderr, "xdc_focused_array; info: %s %s\n",
			Th->information.name, Th->information.create_date);
		}

	else fprintf(stderr, "unknown aperture command\n");


/*
 * I think the next thing is to set impulse. this seems to be the same for
 * all the apertures. the matlab code calls defineImpulseResponse() which
 * calls the matlab routine 'gauspuls', but since I had to write my own
 * I'm going to skip defineImpulseResponse()
 */

	if (strcmp(params.impulse, "gaussian") == 0) {
		impulseResponse = gaussPulse(fractBandwidth, centerFreq, params,
			verbose);

		if (impulseResponse == NULL) {
			fprintf(stderr, "error calling gaussPulse\n");
			return(0);
			}
		}

	else if (strcmp(params.impulse, "exp") == 0) {
/* 		impulseResponse = readExpData(probeInfo, params.samplingFrequencyHz); */
		fprintf(stderr, "calling readExpData\n");
		readExpData(probeInfo, params.samplingFrequencyHz);

		if (impulseResponse == NULL) {
			fprintf(stderr, "error calling readExpData\n");
			return(0);
			}
		}

	info = RECT;

/*
 * note that 'ROWS*' is specific to the type of info you request from xdc_get
 */

	xdcGetSize = ROWS_RECT * noElements * noSubY;

	if (verbose >= 1) fprintf(stderr, "calling xdc_get; size is %d\n", xdcGetSize);

	if ((params.ThData = (double *)malloc(xdcGetSize * sizeof(double))) == NULL) {
		fprintf(stderr, "couldn't allocate space for ThData\n");
		return(0);
		}

	xdc_get(Th, info, params.ThData);

	if (verbose >= 2) {
		fprintf(stderr, "num apertures from sys_con %d\n",
			sys_con->No_apertures);
		fprintf(stderr, "rect? %d\n", sys_con->Use_rectangles);
		fprintf(stderr, "tri? %d\n", sys_con->Use_triangles);

		fprintf(stderr, "back from xdc_get, got %f %f %f\n", params.ThData[7],
			params.ThData[8], params.ThData[9]);

		if (verbose == 3)
			for (i = 0; i < 26 * noElements * noSubX * noSubY; i += 26) {
				fprintf(stderr, "%3.0f %3.0f \n", params.ThData[i],
					params.ThData[i+1]);
				}
		fprintf(stderr, "\n");
		fprintf(stderr, "finished xdc_get\n");
		}

/*
% figure out the axial shift (m) that will need to be applied to the scatterers
% to accomodate the mathematical element shift due to the lens
 *
 * have to tell correctAxialLens() how many data points we have
 */
	
	if (verbose >= 1) fprintf(stderr, "calling cAL\n");

	lensCorrection = correctAxialLens(params.ThData, ROWS_RECT,
		noElements * noSubY, verbose); 

	if (lensCorrection == -1) return(0);

	if (verbose >= 1) fprintf(stderr, "back from cAL, correction %g\n", lensCorrection);

	if (verbose >= 2) for (i = 0; i < 10; i++)
		fprintf(stderr, "uncorrected z %g\n", params.pointsAndNodes[i].z);

	for (i = 0; i < numNodes; i++)
		params.pointsAndNodes[i].z += lensCorrection;
	
	if (verbose >= 2) for (i = 0; i < 10; i++)
		fprintf(stderr, "corrected z %g\n", params.pointsAndNodes[i].z);

/* define the impulse response */

	xdc_impulse(Th, impulseResponse);

	exciteFreqHz = params.frequencyMHz * 1000000;
	stepSize = 1.0 / params.samplingFrequencyHz;

	if (verbose >= 1) fprintf(stderr, "params.frequencyMHz %f exciteFreqHz %f stepSize %g\n",
		params.frequencyMHz, exciteFreqHz, stepSize);

	numSteps = (int )ceil ((double )numCYC / exciteFreqHz / stepSize);

	excitationPulse = alloc_signal(numSteps, 0);

	if (excitationPulse == NULL) {
		fprintf(stderr, "couldn't allocate excitationPulse\n");
		return(0);
		}

	if (verbose >= 1) fprintf(stderr, "setting excitationPulse; numSteps %d\n", numSteps);

	temp = 2 * M_PI * exciteFreqHz * stepSize;

	for (i = 0; i < numSteps; i++) {
		excitationPulse->data[i] = sin(i * temp);
		if (verbose >= 2) fprintf(stderr, "data %g\n", excitationPulse->data[i]);
		}

	if (verbose >= 1) fprintf(stderr, "calling excitation\n");
	if (verbose >= 2) {
		fprintf(stderr, "before call %d %d\n", Th->excitation->allocated,
			Th->excitation->no_samples);

		for (i = 0; i < 30; i++)
			fprintf(stderr, "got %f\n", Th->excitation->data[i]);
		}

	xdc_excitation(Th, excitationPulse);

	if (verbose >= 1) fprintf(stderr, "back from excitation\n");
	if (verbose >= 2) {
		fprintf(stderr, "got %d %d\n", Th->excitation->allocated,
			Th->excitation->no_samples);

		for (i = 0; i < Th->excitation->no_samples; i++)
			fprintf(stderr, "got %f\n", Th->excitation->data[i]);
		}

/* frequency atten. in dB/m/Hz */
	freqAtt = params.alpha_dBcmMHz * 100 / 1E6;

	attF0 = exciteFreqHz;
	att = freqAtt * attF0; /* set non freq. dep. to be centered here */
	set_field("att", att);
	set_field("Freq_att", freqAtt);
	set_field("att_f0", attF0);
	set_field("use_att", 1);

	if (verbose >= 1) fprintf(stderr, "freqAtt %g attF0 %g att %g\n", freqAtt, attF0,
		att);

/*
% compute Ispta at each location for a single tx pulse
% optimizing by computing only relevant nodes... will assume others are zero
 *
 * how many points does calc_hp return?
 *
 */

	if (verbose >= 1) fprintf(stderr, "calling calc_hp; numNodes %d\n", numNodes);

	if (verbose >= 2) field_info;

/*
 * calc_hp just wants the xyz coordinates, but pointsAndNodes includes the
 * node id. may not need the id, but for now I'm going to make a copy.
 */

	if ((points = (point_type *)malloc(numNodes * sizeof(point_type))) == NULL) {
		fprintf(stderr, "couldn't allocate space for points\n");
		return(0);
		}

	for (i = 0; i < numNodes; i++) {
		points[i].x = params.pointsAndNodes[i].x;
		points[i].y = params.pointsAndNodes[i].y;
		points[i].z = params.pointsAndNodes[i].z;
		
		if (verbose >= 2) fprintf(stderr, "x %f, y %f, z %f\n", points[i].x,
			points[i].y, points[i].z);
		}

/* have to init intensity to 0 so we can sum into it */

	if ((intensity = (double *)calloc(numNodes, sizeof(double))) == NULL) {
		fprintf(stderr, "couldn't allocate space for intensity\n");
		return(0);
		}

	if (lowNslow) {
		if (verbose >= 1) fprintf(stderr, "running low-n-slow\n");
		for (i = 0; i < numNodes; i++) {
			if (verbose >= 2) fprintf(stderr, "i %d\n", i);

			pressure = calc_hp(Th, 1, &points[i]);
			if (pressure == NULL) {
				fprintf(stderr, "call to calc_hp failed\n");
				return(0);
				}

			if (verbose == 3) fprintf(stderr, "num samples %d\n",
				pressure[0]->no_samples);
			if (verbose == 3) for (j = 0; j < pressure[0]->no_samples; j++)
				fprintf(stderr, "pressure %g\n", pressure[0]->data[j]);
			for (j = 0; j < pressure[0]->no_samples; j++)
				intensity[i] += pressure[0]->data[j] * pressure[0]->data[j];
			free_signal(pressure[0]);
			}
		}
	else {
		pressure = calc_hp(Th, numNodes, points);

		if (pressure == NULL) {
			fprintf(stderr, "call to calc_hp failed\n");
			return(0);
			}

		for (i = 0; i < numNodes; i++)
			for (j = 0; j < pressure[i]->no_samples; j++)
				intensity[i] += pressure[i]->data[j] * pressure[i]->data[j];
		}

	if (verbose >= 2) for (i = 0; i < numNodes; i++)
		fprintf(stderr, "intensity %g\n", intensity[i]);

	if (verbose >= 1) fprintf(stderr, "done with calc_hp; num samples at 0 %d\n",
		pressure[0]->no_samples);

	if (verbose == 3) for (j = 0; j < pressure[0]->no_samples; j++)
			fprintf(stderr, "%g\n", pressure[0]->data[j]);

	if (verbose == 3) for (i = 0; i < numNodes; i++) {
		fprintf(stderr, "AAAAAAAAAAAAAAAAA; num samples at %d %d\n", i,
			pressure[i]->no_samples);
		for (j = 0; j < pressure[i]->no_samples; j++)
			fprintf(stderr, "j %d pressure %g %g\n", j, pressure[i]->data[j], pressure[i]->data[j]);
		}

/*
 * the original code wrote out the intensity and the field params from
 * 'field2dyna', but I'm going to do it here. the file will be:
 *
 * int numNodes
 *
 * intensity, numNodes doubles
 *
 * fieldParams:
 *
 *  int threads
 *	int soundSpeed_MperSec
 *	int samplingFrequencyHz
 *	double alpha_dBcmMHz
 *	double fnum
 *	point_type focusM (struct of three doubles)
 *	double frequency
 *  length of transducer character string, int
 *  transducer, character string
 *  length of impulse character string, int
 *	impulse, character string
 *	pointsAndNodes, which is numNodes nodeEntry structs (one int,
 *		three doubles)
 *	int ROWS * noElements * noSubY
 *	ThData, which is ROWS * noElements * noSubY doubles. ROWS is a constant
 *		determined by the return of 'xdc_get, and noElements, noSubY come
 *		from the probe description file. in our case, it appears that we only
 *		care about rectangles.
 */

	sprintf(outFileName, "dyna-I-f%.2f-F%.1f-FD%.3f-a%.2f.new",
		params.frequencyMHz, params.fnum, params.focusM.z, params.alpha_dBcmMHz);

	if (verbose >= 1) fprintf(stderr, "file name %s\n", outFileName);

	if (dynaWrite(outFileName, intensity, params, numNodes, xdcGetSize, verbose) == -1) {
		fprintf(stderr, "dynaWrite failed\n");
		return(0);
		}

	return(1);

}
@


1.37
log
@started to add code to deal with the experimental impulse
@
text
@d490 1
a490 1
/* 		impulseResponse = readExpData(probeInfo); */
d492 1
a492 1
		readExpData(probeInfo);
@


1.36
log
@I was calling xdc_convex_focused_array where I should have been calling
xdc_focused_array
@
text
@d57 1
a57 1
cJSON *commands, *impulseCmd, *probeInfo;
a76 1
char *thCmd;
d122 8
a295 14
		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "commands")) == NULL) {
			fprintf(stderr, "couldn't find commands in probe file\n");
			return(0);
			}
		commands = jsonTemp;

		if ((jsonTemp = cJSON_GetObjectItem(commands, "Th")) == NULL) {
			fprintf(stderr, "couldn't find Th in probe file\n");
			return(0);
			}
		thCmd = jsonTemp->valuestring;

		if (verbose >= 2) fprintf(stderr, "Th command %s\n", thCmd);

a453 14
		if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "commands")) == NULL) {
			fprintf(stderr, "couldn't find commands in probe file\n");
			return(0);
			}
		commands = jsonTemp;

		if ((jsonTemp = cJSON_GetObjectItem(commands, "Th")) == NULL) {
			fprintf(stderr, "couldn't find Th in probe file\n");
			return(0);
			}
		thCmd = jsonTemp->valuestring;

		if (verbose >= 2) fprintf(stderr, "Th command %s\n", thCmd);

a470 8
/*
 * this next segment seems unused
 *
	if (verbose >= 2) fprintf(stderr, "impulse response command %s\n",
		cJSON_GetObjectItem(commands, "impulseResponse")->valuestring);

	impulseCmd = cJSON_GetObjectItem(probeInfo, "impulseResponse");
 */
d479 14
a492 1
	impulseResponse = gaussPulse(fractBandwidth, centerFreq, params, verbose);
d494 4
a497 3
	if (impulseResponse == NULL) {
		fprintf(stderr, "error calling gaussPulse\n");
		return(0);
@


1.35
log
@since different probes have different parameters, I moved the reading of
the probe file to be under the transducer type. that does cause some
duplication of code, but I think it's the clearest way.
@
text
@d480 1
a480 1
		Th = xdc_convex_focused_array(noElements, width, height, kerf, Rconvex,
d483 1
a483 1
			fprintf(stderr, "error calling xdc_convex_focused_array\n");
d486 1
a486 1
		if (verbose >= 2) fprintf(stderr, "xdc_convex_focused_array; info: %s %s\n",
@


1.34
log
@added more units to params variables
@
text
@d65 1
a65 2
double width, height, kerf, Rconvex, Rfocus;
double heights;
d101 2
d123 1
a123 1
/* get info from JSON */
d162 30
a191 1
/* if any of the requested items is missing, it's a fatal error. */
d193 23
a215 3
	if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "noElements")) == NULL) {
		fprintf(stderr, "couldn't find noElements in probe file\n");
		return(0);
a216 1
	noElements = jsonTemp->valueint;
d218 1
a218 5
	if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "noSubX")) == NULL) {
		fprintf(stderr, "couldn't find noSubX in probe file\n");
		return(0);
		}
	noSubX = jsonTemp->valueint;
d220 1
a220 5
	if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "noSubY")) == NULL) {
		fprintf(stderr, "couldn't find noSubY in probe file\n");
		return(0);
		}
	noSubY = jsonTemp->valueint;
d222 5
a226 2
	if (verbose >= 2) fprintf(stderr, "elements %d subX %d subY %d\n", noElements,
		noSubX, noSubY);
d228 5
a232 5
	if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "width")) == NULL) {
		fprintf(stderr, "couldn't find width in probe file\n");
		return(0);
		}
	width = jsonTemp->valuedouble;
d234 5
a238 1
	if (verbose >= 2) fprintf(stderr, "width %f\n", width);
d240 2
a241 5
	if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "height")) == NULL) {
		fprintf(stderr, "couldn't find height in probe file\n");
		return(0);
		}
	height = jsonTemp->valuedouble;
d243 5
a247 5
	if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "kerf")) == NULL) {
		fprintf(stderr, "couldn't find kerf in probe file\n");
		return(0);
		}
	kerf = jsonTemp->valuedouble;
d249 1
a249 5
	if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "Rconvex")) == NULL) {
		fprintf(stderr, "couldn't find Rconvex in probe file\n");
		return(0);
		}
	Rconvex = jsonTemp->valuedouble;
d251 5
a255 5
	if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "Rfocus")) == NULL) {
		fprintf(stderr, "couldn't find Rfocus in probe file\n");
		return(0);
		}
	Rfocus = jsonTemp->valuedouble;
d257 5
a261 5
	if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "fractionalBandwidth")) == NULL) {
		fprintf(stderr, "couldn't find fractBandwidth in probe file\n");
		return(0);
		}
	fractBandwidth = jsonTemp->valuedouble;
d263 5
a267 5
	if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "centerFrequency")) == NULL) {
		fprintf(stderr, "couldn't find centerFreq in probe file\n");
		return(0);
		}
	centerFreq = jsonTemp->valuedouble;
d269 5
a273 1
	if (verbose >= 2) fprintf(stderr, "type %s\n", cJSON_GetObjectItem(probeInfo, "probeType")->valuestring);
d275 5
a279 5
	if ((jsonTemp = cJSON_GetObjectItem(probeInfo, "commands")) == NULL) {
		fprintf(stderr, "couldn't find commands in probe file\n");
		return(0);
		}
	commands = jsonTemp;
d281 5
a285 5
	if ((jsonTemp = cJSON_GetObjectItem(commands, "Th")) == NULL) {
		fprintf(stderr, "couldn't find Th in probe file\n");
		return(0);
		}
	thCmd = jsonTemp->valuestring;
d287 1
a287 1
	if (verbose >= 2) fprintf(stderr, "Th command %s\n", thCmd);
d289 5
a293 1
/* set aperture. as of now, there are only 3 xdc calls for this */
d295 2
a296 6
	if (strstr(thCmd, "xdc_concave") != NULL) {
/* optical piston only? should this be handled differently? */
		if (verbose >= 1) fprintf(stderr, "calling xdc_concave\n");
		Th = xdc_concave(9.5E-3, 38E-3, 0.5E-3);
		if (Th == NULL) {
			fprintf(stderr, "error calling xdc_concave\n");
d299 4
a302 1
		}
a303 2
	else if (strstr(thCmd, "xdc_convex_focused_array") != NULL) {
		if (verbose >= 1) fprintf(stderr, "calling xdc_convex_focused_array\n");
d318 1
a318 1
	else if (strstr(thCmd, "xdc_focused_multirow") != NULL) {
d320 1
d322 67
a388 3
		noElementsY = 1;
		heights = height;
		Th = xdc_focused_multirow(noElements, width, noElementsY, &heights,
d396 94
d542 1
a542 1
			for (i = 0; i < 26*noElements*noSubX*noSubY; i += 26) {
@


1.33
log
@got rid of hard-wired probe file name
@
text
@d99 1
a99 1
		fprintf(stderr, "alpha %f\n", params.alpha);
d114 1
a114 1
	set_field("c", params.soundSpeed);
d260 1
a260 1
			noSubY, params.focus.x, params.focus.y, params.focus.z);
d263 1
a263 1
			Rfocus, noSubX, noSubY, params.focus);
d278 1
a278 1
			kerf, kerf, Rfocus, noSubX, noSubY, params.focus);
d418 2
a419 1
	freqAtt = params.alpha * 100 / 1E6; /* frequency atten. in dB/cm/MHz */
d529 1
a529 1
 *	int soundSpeed
d531 1
a531 1
 *	double alpha
d533 1
a533 1
 *	point_type focus (struct of three doubles)
d549 1
a549 1
		params.frequencyMHz, params.fnum, params.focus.z, params.alpha);
@


1.32
log
@started including units in variable names.
@
text
@d123 2
a124 1
	strcpy(jsonFileName, "./c52.json");
@


1.31
log
@mostly added error checking for cJSON_GetObjectItem
@
text
@d69 1
a69 1
double exciteFreq;
d98 1
a98 1
		fprintf(stderr, "sampling frequency %d\n", params.samplingFrequency);
d101 1
a101 1
		fprintf(stderr, "frequency %f\n", params.frequency);
d115 1
a115 1
	set_field("fs", params.samplingFrequency);
d373 2
a374 2
	exciteFreq = params.frequency * 1000000;
	stepSize = 1.0 / params.samplingFrequency;
d376 2
a377 2
	if (verbose >= 1) fprintf(stderr, "params.frequency %f exciteFreq %f stepSize %g\n",
		params.frequency, exciteFreq, stepSize);
d379 1
a379 1
	numSteps = (int )ceil ((double )numCYC / exciteFreq / stepSize);
d390 1
a390 1
	temp = 2 * M_PI * exciteFreq * stepSize;
d419 1
a419 1
	attF0 = exciteFreq;
d528 1
a528 1
 *	int samplingFrequency
d547 1
a547 1
		params.frequency, params.fnum, params.focus.z, params.alpha);
@


1.30
log
@had to make a logic change to verbose check
@
text
@d58 1
d160 19
a178 3
	noElements = cJSON_GetObjectItem(probeInfo, "noElements")->valueint;
	noSubX = cJSON_GetObjectItem(probeInfo, "noSubX")->valueint;
	noSubY = cJSON_GetObjectItem(probeInfo, "noSubY")->valueint;
d183 6
a188 1
	width = cJSON_GetObjectItem(probeInfo, "width")->valuedouble;
d191 17
a207 4
	height = cJSON_GetObjectItem(probeInfo, "height")->valuedouble;
	kerf = cJSON_GetObjectItem(probeInfo, "kerf")->valuedouble;
	Rconvex = cJSON_GetObjectItem(probeInfo, "Rconvex")->valuedouble;
	Rfocus = cJSON_GetObjectItem(probeInfo, "Rfocus")->valuedouble;
d209 5
a213 1
	fractBandwidth = cJSON_GetObjectItem(probeInfo, "fractionalBandwidth")->valuedouble;
d215 11
a225 1
	centerFreq = cJSON_GetObjectItem(probeInfo, "centerFrequency")->valuedouble;
d229 11
a239 2
	commands = cJSON_GetObjectItem(probeInfo, "commands");
	thCmd = cJSON_GetObjectItem(commands, "Th")->valuestring;
d258 2
a259 2
			noElements,width,height,kerf,Rconvex, Rfocus,noSubX,
			noSubY,params.focus.x, params.focus.y, params.focus.z);
d261 2
a262 2
		Th = xdc_convex_focused_array(noElements,width,height,kerf,Rconvex,
			Rfocus,noSubX,noSubY,params.focus);
d276 2
a277 2
		Th = xdc_focused_multirow(noElements,width,noElementsY,&heights,
			kerf,kerf, Rfocus,noSubX,noSubY,params.focus);
d286 3
d293 1
@


1.29
log
@added verbose argument
changed 'debug' to 'verbose'
@
text
@d94 3
a96 1
	if (verbose == 1) {
d118 1
a118 1
	if (verbose == 1) fprintf(stderr, "PARALLEL THREADS: %d param threads %d\n",
d157 1
a157 1
	if (verbose == 2) fprintf(stderr, "array size %d\n", cJSON_GetArraySize(probeInfo));
d163 1
a163 1
	if (verbose == 2) fprintf(stderr, "elements %d subX %d subY %d\n", noElements,
d167 1
a167 1
	if (verbose == 2) fprintf(stderr, "width %f\n", width);
d178 1
a178 1
	if (verbose == 2) fprintf(stderr, "type %s\n", cJSON_GetObjectItem(probeInfo, "probeType")->valuestring);
d183 1
a183 1
	if (verbose == 2) fprintf(stderr, "Th command %s\n", thCmd);
d189 1
a189 1
		if (verbose == 1) fprintf(stderr, "calling xdc_concave\n");
d198 2
a199 2
		if (verbose == 1) fprintf(stderr, "calling xdc_convex_focused_array\n");
		if (verbose == 2) fprintf(stderr, "%d %f %f %f %f %f %d %d %f %f %f\n",
d209 1
a209 1
		if (verbose == 2) fprintf(stderr, "xdc_convex_focused_array; info: %s %s\n",
d215 1
a215 1
		if (verbose == 1) fprintf(stderr, "calling xdc_focused_multirow\n");
d228 1
a228 1
	if (verbose == 2) fprintf(stderr, "impulse response command %s\n",
d255 1
a255 1
	if (verbose == 1) fprintf(stderr, "calling xdc_get; size is %d\n", xdcGetSize);
d264 1
a264 1
	if (verbose == 2) {
d289 1
a289 1
	if (verbose == 1) fprintf(stderr, "calling cAL\n");
d296 1
a296 1
	if (verbose == 1) fprintf(stderr, "back from cAL, correction %g\n", lensCorrection);
d298 1
a298 1
	if (verbose == 2) for (i = 0; i < 10; i++)
d304 1
a304 1
	if (verbose == 2) for (i = 0; i < 10; i++)
d314 1
a314 1
	if (verbose == 1) fprintf(stderr, "params.frequency %f exciteFreq %f stepSize %g\n",
d326 1
a326 1
	if (verbose == 1) fprintf(stderr, "setting excitationPulse; numSteps %d\n", numSteps);
d332 1
a332 1
		if (verbose == 2) fprintf(stderr, "data %g\n", excitationPulse->data[i]);
d335 4
a338 3
	if (verbose == 1) fprintf(stderr, "calling excitation\n");
	if (verbose == 1) fprintf(stderr, "before call %d %d\n",
		Th->excitation->allocated, Th->excitation->no_samples);
d340 3
a342 2
	if (verbose == 2) for (i = 0; i < 30; i++)
		fprintf(stderr, "got %f\n", Th->excitation->data[i]);
d346 4
a349 3
	if (verbose == 1) fprintf(stderr, "back from excitation\n");
	if (verbose == 1) fprintf(stderr, "got %d %d\n", Th->excitation->allocated,
		Th->excitation->no_samples);
d351 3
a353 2
	if (verbose == 2 > 1) for (i = 0; i < Th->excitation->no_samples; i++)
		fprintf(stderr, "got %f\n", Th->excitation->data[i]);
d364 1
a364 1
	if (verbose == 1) fprintf(stderr, "freqAtt %g attF0 %g att %g\n", freqAtt, attF0,
d375 1
a375 1
	if (verbose == 1) fprintf(stderr, "calling calc_hp; numNodes %d\n", numNodes);
d377 1
a377 1
	if (verbose == 2) field_info;
d394 1
a394 1
		if (verbose == 2) fprintf(stderr, "x %f, y %f, z %f\n", points[i].x,
d406 1
a406 1
		if (verbose == 1) fprintf(stderr, "running low-n-slow\n");
d408 1
a408 1
			if (verbose == 2) fprintf(stderr, "i %d\n", i);
d438 1
a438 1
	if (verbose == 2) for (i = 0; i < numNodes; i++)
d441 1
a441 1
	if (verbose == 1) fprintf(stderr, "done with calc_hp; num samples at 0 %d\n",
d487 1
a487 1
	if (verbose == 1) fprintf(stderr, "file name %s\n", outFileName);
@


1.28
log
@fixed code to actually use lowNslow, and to free space allocated by calc_hp
after each call
@
text
@d50 2
a51 1
dynaField(struct FieldParams params, int threads, int numNodes, int lowNslow)
a54 1
int debug = 0;
d94 1
a94 1
	if (debug) {
d116 1
a116 1
	if (debug) fprintf(stderr, "PARALLEL THREADS: %d param threads %d\n",
d155 1
a155 1
	if (debug) fprintf(stderr, "array size %d\n", cJSON_GetArraySize(probeInfo));
d161 1
a161 1
	if (debug) fprintf(stderr, "elements %d subX %d subY %d\n", noElements,
d165 1
a165 1
	if (debug) fprintf(stderr, "width %f\n", width);
d176 1
a176 1
	if (debug) fprintf(stderr, "type %s\n", cJSON_GetObjectItem(probeInfo, "probeType")->valuestring);
d181 1
a181 1
	if (debug) fprintf(stderr, "Th command %s\n", thCmd);
d187 1
a187 1
		if (debug) fprintf(stderr, "calling xdc_concave\n");
d196 2
a197 2
		if (debug) fprintf(stderr, "calling xdc_convex_focused_array\n");
		if (debug) fprintf(stderr, "%d %f %f %f %f %f %d %d %f %f %f\n",
d207 1
a207 1
		if (debug) fprintf(stderr, "xdc_convex_focused_array; info: %s %s\n",
d213 1
a213 1
		if (debug) fprintf(stderr, "calling xdc_focused_multirow\n");
d226 1
a226 1
	if (debug) fprintf(stderr, "impulse response command %s\n",
d238 1
a238 1
	impulseResponse = gaussPulse(fractBandwidth, centerFreq, params, debug);
a244 7
	if (debug) fprintf(stderr, "back\n");
	if (debug) fprintf(stderr, "impulse response %f %f %f\n",
		impulseResponse->data[0], impulseResponse->data[1],
		impulseResponse->data[2]);
	if (debug) fprintf(stderr, "num apertures from sys_con %d\n",
		sys_con->No_apertures);

d253 1
a253 1
	if (debug) fprintf(stderr, "calling xdc_get; size is %d\n", xdcGetSize);
d262 1
a262 1
	if (debug) {
d271 1
a271 1
		if (debug > 1)
d287 1
a287 1
	if (debug) fprintf(stderr, "calling cAL\n");
d290 1
a290 1
		noElements * noSubY, debug); 
d294 1
a294 1
	if (debug) fprintf(stderr, "back from cAL, correction %g\n", lensCorrection);
d296 1
a296 1
	if (debug) for (i = 0; i < 10; i++)
d302 1
a302 1
	if (debug) for (i = 0; i < 10; i++)
d312 1
a312 1
	if (debug) fprintf(stderr, "params.frequency %f exciteFreq %f stepSize %g\n",
d324 1
a324 1
	if (debug) fprintf(stderr, "setting excitationPulse; numSteps %d\n", numSteps);
d330 1
a330 1
		if (debug) fprintf(stderr, "data %g\n", excitationPulse->data[i]);
d333 2
a334 2
	if (debug) fprintf(stderr, "calling excitation\n");
	if (debug) fprintf(stderr, "before call %d %d\n",
d337 1
a337 1
	if (debug) for (i = 0; i < 30; i++)
d342 2
a343 2
	if (debug) fprintf(stderr, "back from excitation\n");
	if (debug) fprintf(stderr, "got %d %d\n", Th->excitation->allocated,
d346 1
a346 1
	if (debug > 1) for (i = 0; i < Th->excitation->no_samples; i++)
d358 1
a358 1
	if (debug) fprintf(stderr, "freqAtt %g attF0 %g att %g\n", freqAtt, attF0,
d369 1
a369 1
	if (debug) fprintf(stderr, "calling calc_hp; numNodes %d\n", numNodes);
d371 1
a371 1
	if (debug) field_info;
d388 1
a388 1
		if (debug) fprintf(stderr, "x %f, y %f, z %f\n", points[i].x,
d400 1
a400 1
		fprintf(stderr, "running low-n-slow\n");
d402 1
a402 1
			if (debug) fprintf(stderr, "i %d\n", i);
d410 1
a410 1
			if (debug) fprintf(stderr, "num samples %d\n",
d412 1
a412 1
			if (debug) for (j = 0; j < pressure[0]->no_samples; j++)
d432 1
a432 1
	if (debug) for (i = 0; i < numNodes; i++)
d435 1
a435 1
	if (debug) fprintf(stderr, "done with calc_hp; num samples at 0 %d\n",
d438 1
a438 1
	if (debug) for (j = 0; j < pressure[0]->no_samples; j++)
d441 1
a441 1
	if (debug > 1) for (i = 0; i < numNodes; i++) {
d481 1
a481 1
	if (debug) fprintf(stderr, "file name %s\n", outFileName);
d483 1
a483 1
	if (dynaWrite(outFileName, intensity, params, numNodes, xdcGetSize) == -1) {
@


1.27
log
@cleaned up the code a bit
@
text
@d406 1
a406 1
	if (debug) {
d423 1
@


1.26
log
@updated to reflect changes in JSON files
@
text
@d52 1
d67 2
a68 2
point_type *focus, *points;
double exciteFreq, texcite;
d105 6
d122 1
a122 1
	if ((jsonInput = fopen(jsonFileName,"rb")) == NULL) {
d127 1
a127 1
	fseek(jsonInput,0,SEEK_END);
d130 1
a130 1
	fseek(jsonInput,0,SEEK_SET);
d132 1
a132 1
	if ((data = (char*)malloc(len+1)) == NULL) {
d137 1
a137 1
	if (fread(data,1,len,jsonInput) != len) {
d146 1
a146 1
		printf("Error before: [%s]\n",cJSON_GetErrorPtr());
d322 1
a322 1
	numSteps = ceil ((double )numCYC / exciteFreq / stepSize);
@


1.25
log
@added a bunch of error checks
@
text
@d61 2
a62 2
int no_elements, no_sub_x, no_sub_y;
int no_elements_y;
d113 1
a113 1
	strcpy(jsonFileName, "./c52Fixed.json");
d150 3
a152 3
	no_elements = cJSON_GetObjectItem(probeInfo, "no_elements")->valueint;
	no_sub_x = cJSON_GetObjectItem(probeInfo, "no_sub_x")->valueint;
	no_sub_y = cJSON_GetObjectItem(probeInfo, "no_sub_y")->valueint;
d154 2
a155 2
	if (debug) fprintf(stderr, "elements %d subX %d subY %d\n", no_elements,
		no_sub_x, no_sub_y);
d169 1
a169 1
	if (debug) fprintf(stderr, "type %s\n", cJSON_GetObjectItem(probeInfo, "probe_type")->valuestring);
d191 2
a192 2
			no_elements,width,height,kerf,Rconvex, Rfocus,no_sub_x,
			no_sub_y,params.focus.x, params.focus.y, params.focus.z);
d194 2
a195 2
		Th = xdc_convex_focused_array(no_elements,width,height,kerf,Rconvex,
			Rfocus,no_sub_x,no_sub_y,params.focus);
d207 1
a207 1
		no_elements_y = 1;
d209 2
a210 2
		Th = xdc_focused_multirow(no_elements,width,no_elements_y,&heights,
			kerf,kerf, Rfocus,no_sub_x,no_sub_y,params.focus);
d222 1
a222 1
	impulseCmd = cJSON_GetObjectItem(probeInfo, "impulse_response");
d251 1
a251 1
	xdcGetSize = ROWS_RECT * no_elements * no_sub_y;
d272 1
a272 1
			for (i = 0; i < 26*no_elements*no_sub_x*no_sub_y; i += 26) {
d290 1
a290 1
		no_elements * no_sub_y, debug); 
d470 3
a472 3
 *	int ROWS * no_elements * no_sub_y
 *	ThData, which is ROWS * no_elements * no_sub_y doubles. ROWS is a constant
 *		determined by the return of 'xdc_get, and no_elements, no_sub_y come
@


1.24
log
@added to output comment
@
text
@d2 2
a3 1
% function [intensity, FIELD_PARAMS]=dynaField(FIELD_PARAMS, threads, lownslow)
d54 1
a54 1
aperture_type *Th;
d57 2
a58 1
FILE *input;
d68 3
a70 3
signal_type *excitationPulse;
signal_type *impulseResponse, *gaussPulse();
signal_type **pressure;
d102 1
a102 1
			}
d113 23
a135 7
	input = fopen("./c52Fixed.json","rb");
	fseek(input,0,SEEK_END);
	len=ftell(input );
	fseek(input,0,SEEK_SET);
	data=(char*)malloc(len+1);
	fread(data,1,len,input);
	fclose(input);
d140 1
d144 1
a144 2
		out=cJSON_Print(probeInfo);
/* 		printf("%s\n",out); */
d159 1
d164 1
d166 1
d173 1
d180 1
a180 1
		fprintf(stderr, "calling xdc_concave\n");
d182 4
d189 1
a189 1
		fprintf(stderr, "calling xdc_convex_focused_array\n");
d196 4
d206 1
a206 1
		fprintf(stderr, "calling xdc_focused_multirow\n");
d211 4
d233 5
d255 4
a258 2
	params.ThData = (double *)malloc(xdcGetSize * sizeof(double));
	
d285 1
a285 1
*/
d292 2
d314 1
d319 6
a324 1
	fprintf(stderr, "setting excitationPulse; numSteps %d\n", numSteps);
d364 4
a367 4
*
* how many points does calc_hp return?
*
*/
d378 4
a381 1
	points = (point_type *)malloc(numNodes * sizeof(point_type));
d394 4
a397 1
	intensity = (double *)calloc(numNodes, sizeof(double));
d403 1
d405 5
d420 6
d477 1
a477 1
	sprintf(outFileName, "dyna-I-f%.2f-F%.1f-FD%.3f-a%.2f.ned",
d480 6
a485 1
	fprintf(stderr, "file name %s\n", outFileName);
d487 1
a487 1
	dynaWrite(outFileName, intensity, params, numNodes, xdcGetSize);
@


1.23
log
@moved output code to dynaWrite(), removed some unused variables
@
text
@d221 1
a221 1
	if (1) {
d344 1
a344 1
	if (1) {
d397 3
a399 1
 *	transducer, character string
@


1.22
log
@looks pretty good for data output.
@
text
@d63 1
a63 1
double convexRadius, elvFocus, pitch, fractBandwidth, centerFreq;
a74 2
double f0, phase, bw;
char *wavetype;
a77 1
FILE *outptr;
a144 3
	convexRadius = cJSON_GetObjectItem(probeInfo, "convex_radius")->valuedouble;
	elvFocus = cJSON_GetObjectItem(probeInfo, "elv_focus")->valuedouble;
	pitch = cJSON_GetObjectItem(probeInfo, "pitch")->valuedouble;
a189 8
	f0 = cJSON_GetObjectItem(impulseCmd, "f0")->valueint;
	phase = cJSON_GetObjectItem(impulseCmd, "phase")->valueint;
	bw = cJSON_GetObjectItem(impulseCmd, "bw")->valueint;
	wavetype = cJSON_GetObjectItem(impulseCmd, "wavetype")->valuestring;
	
	if (debug) fprintf(stderr, "f0 %f phase %f bw %f\n", f0, phase, bw);
	if (debug) fprintf(stderr, "wavetype %s\n", wavetype);

d413 1
a413 92
/* open output file */

    if ((outptr = fopen(outFileName, "wb")) == NULL) {
		fprintf(stderr, "couldn't open output file %s\n", outFileName);
		exit(EXIT_FAILURE);
		}

	if (fwrite(&numNodes, sizeof(int), 1, outptr) != 1) {
		fprintf(stderr, "failed to write numNodes\n");
		exit(EXIT_FAILURE);
		}

	if (fwrite(&params.threads, sizeof(int), 1, outptr) != 1) {
		fprintf(stderr, "failed to write threads\n");
		exit(EXIT_FAILURE);
		}

	if (fwrite(&params.soundSpeed, sizeof(int), 1, outptr) != 1) {
		fprintf(stderr, "failed to write soundSpeed\n");
		exit(EXIT_FAILURE);
		}

	if (fwrite(&params.samplingFrequency, sizeof(int), 1, outptr) != 1) {
		fprintf(stderr, "failed to write samplingFrequency\n");
		exit(EXIT_FAILURE);
		}

	if (fwrite(intensity, sizeof(double), numNodes, outptr) != numNodes) {
		fprintf(stderr, "failed to write intensity\n");
		exit(EXIT_FAILURE);
		}

	if (fwrite(&params.alpha, sizeof(double), 1, outptr) != 1) {
		fprintf(stderr, "failed to write alpha\n");
		exit(EXIT_FAILURE);
		}

	if (fwrite(&params.fnum, sizeof(double), 1, outptr) != 1) {
		fprintf(stderr, "failed to write fnum\n");
		exit(EXIT_FAILURE);
		}

	if (fwrite(&params.focus, sizeof(point_type), 1, outptr) != 1) {
		fprintf(stderr, "failed to write focus\n");
		exit(EXIT_FAILURE);
		}

	if (fwrite(&params.frequency, sizeof(double), 1, outptr) != 1) {
		fprintf(stderr, "failed to write frequency\n");
		exit(EXIT_FAILURE);
		}

	i = strlen(params.transducer) + 1;

	if (fwrite(&i, sizeof(int), 1, outptr) != 1) {
		fprintf(stderr, "failed to write length of transducer string\n");
		exit(EXIT_FAILURE);
		}

	if (fwrite(params.transducer, sizeof(char), i, outptr) != i) {
		fprintf(stderr, "failed to write transducer\n");
		exit(EXIT_FAILURE);
		}

	i = strlen(params.impulse) + 1;

	if (fwrite(&i, sizeof(int), 1, outptr) != 1) {
		fprintf(stderr, "failed to write length of impulse string\n");
		exit(EXIT_FAILURE);
		}

	if (fwrite(params.impulse, i, 1, outptr) != 1) {
		fprintf(stderr, "failed to write impulse\n");
		exit(EXIT_FAILURE);
		}

	if (fwrite(params.pointsAndNodes, sizeof(struct nodeEntry), numNodes, outptr) != numNodes) {
		fprintf(stderr, "failed to write points and nodes\n");
		exit(EXIT_FAILURE);
		}

	if (fwrite(&xdcGetSize, sizeof(int), 1, outptr) != 1) {
		fprintf(stderr, "failed to write size of xdc_get\n");
		exit(EXIT_FAILURE);
		}

/*
*/
	if (fwrite(params.ThData, sizeof(double), xdcGetSize, outptr) != xdcGetSize) {
		fprintf(stderr, "failed to write ThData\n");
		exit(EXIT_FAILURE);
		}
a414 1
	fclose(outptr);
@


1.21
log
@made some progress on writing the output file; still not done
@
text
@d228 1
a228 1
	if (1) fprintf(stderr, "calling xdc_get; size is %d\n", xdcGetSize);
d235 1
a235 1
	if (debug) {
d415 1
d508 8
a515 1
	if (fwrite(params.ThData, sizeof(double), xdcGetSize, outptr) != ROWS_RECT * no_elements * no_sub_y) {
@


1.20
log
@added code to write out results; not tested.
@
text
@d81 1
d226 5
a230 1
	params.ThData = (double *)malloc(ROWS_RECT * no_elements * no_sub_y * sizeof(double));
a231 1
	if (debug) fprintf(stderr, "calling xdc_get\n");
d478 8
a485 1
	if (fwrite(params.transducer, sizeof(char), strlen(params.transducer), outptr) != strlen(params.transducer)) {
d490 8
a497 1
	if (fwrite(params.impulse, sizeof(char), strlen(params.impulse), outptr) != strlen(params.impulse)) {
d507 1
a507 1
	if (fwrite(params.ThData, sizeof(double), ROWS_RECT * no_elements * no_sub_y, outptr) != ROWS_RECT * no_elements * no_sub_y) {
@


1.19
log
@corrected some comments and a constant, started work on writing output
file.
@
text
@d394 2
d400 3
a403 2
 *	pointsAndNodes, which is numNodes nodeEntry structs (one int,
 *		three doubles)
d409 2
a410 3
 *  int threads
 *	int soundSpeed
 *	int samplingFrequency
d429 20
d451 40
@


1.18
log
@added intensity calculation.
@
text
@d44 2
a45 1
#define ROWS 26	/* amount of information xdc_get returns for each rectangle */
d79 2
d222 1
a222 2
 * note that ROWS won't be right for the other xdc calls; they return
 * a different amount of data for each point
d225 1
a225 1
	params.ThData = (double *)malloc(ROWS * no_elements * no_sub_y * sizeof(double));
d258 1
a258 1
	lensCorrection = correctAxialLens(params.ThData, ROWS,
d374 1
a374 1
	if (1) for (i = 0; i < numNodes; i++)
d390 43
@


1.17
log
@sped up the calculation of excitation pulse, messed around with debugging
@
text
@d68 1
d239 1
a239 1
			for (i = 0; i < 26*no_elements*no_sub_x*no_sub_y; i+=26) {
d348 5
a352 1
	if (lowNslow) {
d361 2
d365 1
a365 1
	else
d367 7
d379 1
a379 1
			fprintf(stderr, "pressure %g\n", pressure[0]->data[j]);
@


1.16
log
@some more corrections, error cleanup
@
text
@a54 1
cJSON *item;
a71 1
double *intensity;
d76 1
d258 4
a261 1
	if (debug) fprintf(stderr, "back from cAL\n");
d265 3
d284 2
d287 2
a288 1
		excitationPulse->data[i] = sin(2 * M_PI * exciteFreq * i * stepSize);
d295 1
a295 1
	if (debug > 1) for (i = 0; i < 30; i++)
d316 3
d367 1
a367 1
	if (debug) for (i = 0; i < numNodes; i++) {
d371 1
a371 1
			fprintf(stderr, "pressure %g\n", pressure[i]->data[j]);
@


1.15
log
@more cleanup on debugging
@
text
@d38 1
d273 1
a273 1
	numSteps = roundf ((double )numCYC / exciteFreq / stepSize);
d318 17
a334 1
	field_info;
d337 9
a345 2
		for (i = 0; i < numNodes; i++)
			pressure = calc_hp(Th, 1, &params.pointsAndNodes[i]);
d348 1
a348 1
		pressure = calc_hp(Th, numNodes, params.pointsAndNodes);
d356 3
a358 2
	if (debug > 1) for (i = 0; i < numNodes; i++) {
		fprintf(stderr, "num samples at %d %d\n", i, pressure[i]->no_samples);
@


1.14
log
@I think this has the correct call to gaussPulse, returning signal_type
@
text
@d50 1
a50 1
int debug = 1;
d105 2
a106 1
	if (debug) fprintf(stderr, "PARALLEL THREADS: %d param threads %d\n", threads, params.threads);
d134 2
a135 2
	if (debug) fprintf(stderr, "elements %d subX %d subY %d\n", no_elements, no_sub_x,
		no_sub_y);
a148 2
/*
*/
d150 1
d171 1
a171 1
		if (debug) fprintf(stderr, "from xdc_convex_focused_array got info: %s %s\n",
d186 3
a188 1
	if (debug) fprintf(stderr, "impulse response command %s\n", cJSON_GetObjectItem(commands, "impulseResponse")->valuestring);
d206 1
a206 1
	impulseResponse = gaussPulse(fractBandwidth, centerFreq, params, 1);
d208 6
a213 4
	if (1) fprintf(stderr, "back\n");
	if (1) fprintf(stderr, "impulse response %f %f %f\n", impulseResponse->data[0],
		impulseResponse->data[1], impulseResponse->data[2]);
	if (debug) fprintf(stderr, "num apertures from sys_con %d\n", sys_con->No_apertures);
d234 2
a235 1
		fprintf(stderr, "back from xdc_get, got %f %f %f\n", params.ThData[7], params.ThData[8], params.ThData[9]);
d237 5
a241 4
		if (debug > 1) for (i = 0; i < 26*no_elements*no_sub_x*no_sub_y; i+=26) {
			fprintf(stderr, "%3.0f %3.0f \n", params.ThData[i],
				params.ThData[i+1]);
			}
d256 1
a256 1
		no_elements * no_sub_y); 
d270 2
a271 1
	fprintf(stderr, "params.frequency %f exciteFreq %f stepSize %g\n", params.frequency, exciteFreq, stepSize);
d282 5
a286 4
	fprintf(stderr, "calling excitation\n");
	fprintf(stderr, "before call %d %d\n", Th->excitation->allocated, Th->excitation->no_samples);
/*
	for (i = 0; i < 30; i++)
a287 1
*/
d291 5
a295 4
	fprintf(stderr, "back from excitation\n");
	fprintf(stderr, "got %d %d\n", Th->excitation->allocated, Th->excitation->no_samples);
/*
	for (i = 0; i < Th->excitation->no_samples; i++)
a296 1
*/
d315 1
a315 1
fprintf(stderr, "calling calc_hp; numNodes %d\n", numNodes);
d326 2
a327 1
fprintf(stderr, "done with calc_hp; num samples at 0 %d\n", pressure[0]->no_samples);
d329 1
a329 1
		for (j = 0; j < pressure[0]->no_samples; j++)
d331 2
a332 2
/*
	for (i = 0; i < numNodes; i++) {
a336 1
*/
@


1.13
log
@one or two bugs fixes, some clean up
@
text
@a3 2
* no need for lownslow because C can't compute the whole array at once
*
d45 3
a47 1
dynaField(struct FieldParams params, int threads, int numNodes)
a50 1
sys_con_type   *sys_con;      /*  System constants for Field II */ 
d53 1
a53 1
cJSON *commands, *impulseResponseCmd, *probeInfo;
d66 1
d73 1
a73 2
char *thCmd, *impulseCmd;
double *impulseResponse;
d76 1
a76 1
double lensCorrection;
d187 1
a187 1
	impulseResponseCmd = cJSON_GetObjectItem(probeInfo, "impulse_response");
d189 4
a192 4
	f0 = cJSON_GetObjectItem(impulseResponseCmd, "f0")->valueint;
	phase = cJSON_GetObjectItem(impulseResponseCmd, "phase")->valueint;
	bw = cJSON_GetObjectItem(impulseResponseCmd, "bw")->valueint;
	wavetype = cJSON_GetObjectItem(impulseResponseCmd, "wavetype")->valuestring;
d204 1
a204 1
	impulseResponse = gaussPulse(fractBandwidth, centerFreq, params, debug);
d206 3
a208 2
	if (debug) fprintf(stderr, "impulse response %f %f %f\n", impulseResponse[0],
		impulseResponse[1], impulseResponse[2]);
a217 3
/* is this needed?
*/

d248 1
d251 1
a256 1
#if 0
a266 5
/*
	excitationPulse = (signal_type *)malloc(sizeof(signal_type));
	excitationPulse->data = (double *)malloc(numSteps * sizeof(double));
*/

d271 1
a271 3
	excitationPulse->data[0] = 0;

	for (i = 1; i < numSteps; i++) {
d276 1
a276 1
	fprintf(stderr, "got %d %d\n", Th->excitation->allocated, Th->excitation->no_samples);
a307 2
	intensity = (double *)malloc(sizeof(double));

a308 7
/*
	for (i = 0; i < 20; i++)
		fprintf(stderr, "points %f %f %f\n",
			params.pointsAndNodes[i].x,
			params.pointsAndNodes[i].y,
			params.pointsAndNodes[i].z);
*/
d312 6
a317 3
int a;

	pressure = calc_hp(Th, numNodes, params.pointsAndNodes);
d321 2
a322 4
/* 	pressure = calc_hp(Th, numNodes, points); */

		for (a = 0; a < pressure[0]->no_samples; a++)
			fprintf(stderr, "pressure %g\n", pressure[0]->data[a]);
d326 2
a327 2
		for (a = 0; a < pressure[i]->no_samples; a++)
			fprintf(stderr, "pressure %g\n", pressure[i]->data[a]);
a330 1
#endif
@


1.12
log
@some more progress with calc_hp
@
text
@d50 1
a50 1
int debug = 0;
d77 1
d103 1
d105 1
d164 1
a164 1
	if (strstr(thCmd, "xdc_convex_focused_array") != NULL) {
d166 4
d172 1
a172 1
		if (debug) fprintf(stderr, "from xdc_focused_multirow got info: %s %s\n",
d201 1
a201 1
 * calls * the matlab routine 'gauspuls', but since I had to write my own
d213 8
d223 2
d227 15
a241 13
/*
	fprintf(stderr, "num apertures from sys_con %d\n", sys_con->No_apertures);
	fprintf(stderr, "rect? %d\n", sys_con->Use_rectangles);
	fprintf(stderr, "tri? %d\n", sys_con->Use_triangles);

	fprintf(stderr, "back from xdc_get, got %f\n", foo[0]);

	for (i = 0; i < 26*no_elements*no_sub_x*no_sub_y; i+=26) {
		fprintf(stderr, "%3.0f %3.0f \n", foo[i],foo[i+1]);
	}
	fprintf(stderr, "\n");
	fprintf(stderr, "done from xdc_get\n");
*/
d246 2
d250 13
d267 1
a267 1
	numSteps = (int) (numCYC / exciteFreq / stepSize);
d286 1
a288 1
/*
d295 2
a296 1
	for (i = 0; i < 30; i++)
a297 1
/*
d319 1
a320 1
fprintf(stderr, "calling calc_hp; numNodes %d\n", numNodes);
d330 1
a330 1
	points = (point_type *)malloc(numNodes * sizeof(point_type));
d332 1
a332 1
int a;
d334 1
a334 6
	for (i=0; i< numNodes; i++) {
		a=i;
		points[i].x = (a-numNodes/2)/numNodes*20.0/1000.0;
		points[i].y = 0.0;
		points[i].z = (a/numNodes*50.0+15.0)/1000.0;
		}
d336 1
a336 2
/* 	pressure = calc_h(Th, numNodes, params.pointsAndNodes); */
	pressure = calc_hp(Th, numNodes, points);
d338 5
a342 1
	for (i = 0; i < numNodes; i++)
d345 2
d348 1
a348 3
fprintf(stderr, "done with calc_hp\n");
			

@


1.11
log
@more progress on getting calc_hp right.
@
text
@d53 1
a53 1
int info;
d64 1
a64 1
point_type *focus;
a72 1
point_type points;
d215 6
a220 2
	for (i = 0; i < 20; i++)
	fprintf(stderr, "back from xdc_get, got %f\n", params.ThData[i]);
d235 1
d238 4
a249 1
/*
d254 1
d256 1
d258 1
a258 1
/*
d263 1
d282 3
d286 6
a291 2
	pressure = (signal_type **)malloc(sizeof(signal_type *));
	excitationPulse->data = (double *)malloc(numSteps * sizeof(double));
d294 5
a298 1
	intensity = (double *)malloc(sizeof(double));
d300 5
a304 12
fprintf(stderr, "calling calc_hp; numNodes %d\n", numNodes);
	for (i = 0; i < numNodes; i++) {
/* fprintf(stderr, "in calc_hp, i is %d\n", i); */
		points.x = params.pointsAndNodes[i].x;
		points.y = params.pointsAndNodes[i].y;
		points.z = params.pointsAndNodes[i].z;
/* fprintf(stderr, "in calc_hp, point is %f %f %f\n", points.x, points.y, points.z); */

		calc_hp(Th, 1, &points);
/* 		pressure = calc_hp(Th, 1, points); */
/* 		fprintf(stderr, "pressure %f\n", pressure[i]->data[0]); */
/* 		for (j = 0; j < ?; j++) intensity[i] +=  *(pressure[j]->data) * *(pressure[j]->data; */
d306 8
@


1.10
log
@did some cleanup on the debugging, made some more progress on xdc_get.
working on excitation now.
@
text
@d73 1
a73 1
point_type *points;
d90 10
a99 1
	if (debug) fprintf(stderr, "sampling frequency %d\n", params.samplingFrequency);
d211 1
a215 1
/*
d242 1
d244 1
d246 2
a247 1
		fprintf(stderr, "got %f\n", Th->excitation[i]);
d249 1
d251 1
d253 2
a254 1
		fprintf(stderr, "got %f\n", Th->excitation[i]);
d272 5
d279 1
d281 9
a289 5
		points->x = params.pointsAndNodes[i].x;
		points->y = params.pointsAndNodes[i].y;
		points->z = params.pointsAndNodes[i].z;

		pressure = calc_hp(Th, 1, points);
d292 1
@


1.9
log
@made some fixed for impulse response, read some more constants from JSON
file
@
text
@d44 3
d50 1
d53 1
a53 1
char *info;
a63 1
double *foo;
a78 5
/*
for (i = 0; i < 13; i++)
        fprintf(stderr, "in dynaField, node %d is %d, %f, %f, %f\n", i, params.pointsAndNodes[i].nodeID, params.pointsAndNodes[i].x, params.pointsAndNodes[i].y, params.pointsAndNodes[i].z);

*/
d90 1
a90 1
	fprintf(stderr, "sampling frequency %d\n", params.samplingFrequency);
d95 1
a95 1
	fprintf(stderr, "PARALLEL THREADS: %d param threads %d\n", threads, params.threads);
d117 1
a117 1
	fprintf(stderr, "array size %d\n", cJSON_GetArraySize(probeInfo));
d123 1
a123 1
	fprintf(stderr, "elements %d subX %d subY %d\n", no_elements, no_sub_x,
d127 1
a127 1
	fprintf(stderr, "width %f\n", width);
d140 1
a140 1
	fprintf(stderr, "type %s\n", cJSON_GetObjectItem(probeInfo, "probe_type")->valuestring);
d143 1
a143 1
	fprintf(stderr, "Th command %s\n", thCmd);
d157 1
a157 1
		fprintf(stderr, "from xdc_focused_multirow got info: %s %s\n",
d172 1
a172 1
	fprintf(stderr, "impulse response command %s\n", cJSON_GetObjectItem(commands, "impulseResponse")->valuestring);
d180 2
a181 2
	fprintf(stderr, "f0 %f phase %f bw %f\n", f0, phase, bw);
	fprintf(stderr, "wavetype %s\n", wavetype);
d190 1
a190 1
	impulseResponse = gaussPulse(fractBandwidth, centerFreq, params);
d192 1
a192 1
	fprintf(stderr, "impulse response %f %f %f\n", impulseResponse[0],
d194 1
a194 1
	fprintf(stderr, "num apertures from sys_con %d\n", sys_con->No_apertures);
d196 1
a196 2
	info = "rect";
	fprintf(stderr, "info is %s\n", info);
d198 1
a198 1
/* 	foo = (double *)malloc(26*no_elements*no_sub_y*sizeof(double)); */
d200 1
a200 1
	xdc_get(Th, info, foo);
d206 1
a206 2
	fprintf(stderr, "back from xdc_get, got %f\n", foo[0]);

d208 1
a208 1
	fprintf(stderr, "back from xdc_get, got %f\n", foo[i]);
a209 1
/*
d234 2
d238 2
@


1.8
log
@some more progress on reading the JSON file, added impulse response
@
text
@d50 1
a50 1
cJSON *commands, *impulseResponse, *probeInfo;
d72 3
d92 2
d151 1
d156 1
d159 2
d165 1
d175 9
a183 4
	impulseResponse = cJSON_GetObjectItem(probeInfo, "impulse_response");
	fprintf(stderr, "center freq %d\n", cJSON_GetObjectItem(impulseResponse, "f0")->valueint);
	fprintf(stderr, "phase %d\n", cJSON_GetObjectItem(impulseResponse, "phase")->valueint);
	fprintf(stderr, "bw %d\n", cJSON_GetObjectItem(impulseResponse, "bw")->valueint);
d194 2
a195 1
	fprintf(stderr, "#elements %d\n", Th->no_elements);
d199 1
d204 1
d208 3
a210 2
/*
*/
d214 2
@


1.7
log
@made some more progress on handling the aperture commands
@
text
@d21 1
a21 1
%   FIELD_PARAMS.Impulse (string) - 'guassian','exp'; use a Gaussian function
d56 1
d58 2
d129 5
d157 2
a158 1
		Th = xdc_focused_multirow(no_elements,width,no_elements_y,height,
d172 3
a174 1
 * all the apertures
d176 2
@


1.6
log
@some code corrections
@
text
@d68 1
d128 1
d131 24
a154 1
	fprintf(stderr, "Th %s\n", cJSON_GetObjectItem(commands, "Th")->valuestring);
a159 1
*/
d161 4
a164 3
/* I think the next thing is to set Th, impulse */

	Th = xdc_convex_focused_array(no_elements,width,height,kerf,Rconvex,Rfocus,no_sub_x,no_sub_y,params.focus);
@


1.5
log
@getting closer to having all the code
@
text
@d3 3
d44 1
a44 1
dynaField(struct FieldParams params, int threads, int lowNslow, int numNodes)
d46 1
a46 1
int i;
d61 1
d66 2
d72 1
a73 1

d88 1
a88 1
	fprintf(stderr, "PARALLEL THREADS: %d\n", threads);
d146 1
a146 1
	foo = (double *)malloc(26*1344*sizeof(double));
d152 3
a154 1
	for (i = 0; i < 40; i++)
d156 1
d163 2
a164 2
	exciteFreq = params.frequency * 1E6;
	stepSize = 1 / exciteFreq;
d166 2
a167 1
	numSteps = (int) (numCYC * exciteFreq) * 2;
d169 1
d171 1
d175 1
a175 1
	for (i = 0; i < numSteps; i++) {
d179 1
d181 1
d195 10
d206 3
a208 4
	if (lowNslow) {
		fprintf(stderr, "running low-n-slow\n");
		for (i = 0; i < numNodes; i++) {
*/
@


1.4
log
@added some more code
@
text
@d24 1
d41 1
a41 1
dynaField(struct FieldParams params, int threads, int lowNslow)
d56 3
a58 1
double exciteFreq, texcite, *excitationPulse, stepSize;
d159 1
a159 1
	excitationPulse = (double *)malloc(numSteps * sizeof(double));
d161 1
a161 1
	excitationPulse[0] = 0;
d164 1
a164 1
		excitationPulse[i] = sin(2 * M_PI * exciteFreq * i * stepSize);
d173 15
a187 4
	set_field('att', att);
	set_field('Freq_att', freqAtt);
	set_field('att_f0', attF0);
	set_field('use_att', 1);
@


1.3
log
@I think that xdc_convex_focused_array is working, but xdc_get isn't
@
text
@d36 1
a36 1
#include <pthread.h>	/* needed to keep types.h (from field_II.h) happy */
d55 9
d97 1
a97 1
		printf("%s\n",out);
d133 1
d140 34
a173 1
	fprintf(stderr, "back from xdc_get, got %f %f %f\n", foo[4], foo[5], foo[6]);
@


1.2
log
@first cut at parsing JSON
@
text
@d35 1
d42 1
d46 2
a47 1
cJSON *probeInfo;
d51 4
a87 1
		cJSON_Delete(probeInfo);
d92 27
d121 4
d126 5
a130 1
	xdc_get(Th, info, params.ThData);
@


1.1
log
@Initial revision
@
text
@d37 1
d44 4
d64 21
@
